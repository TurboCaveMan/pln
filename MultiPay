pragma solidity ^0.8.7;

contract Multipay {

    address payable admin;

    constructor() public {
        admin = payable(msg.sender);
    }

    struct User{
        address payable UserAddress;
        uint fee; 
    }    


    function Pay_Users(User[] calldata _List) external payable {
        uint _paid = 0;
        uint _totalfee = 0;
        uint _fee;
        User memory Payee;
        
        for(uint i = 0; i < _List.length; i++) {
            Payee=_List[i];
            _fee = Payee.fee * 1 ether * 750 / 1000;

            Payee.UserAddress.transfer(_fee);
            _paid = _paid + (Payee.fee * 1 ether);
            _totalfee = _totalfee + _fee;
        }

        if(msg.value < _paid) {
            revert();
        }

        admin.transfer(_paid-_totalfee);

    }

}
//[
//  ["0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2","1"], 
//  ["0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db","1"]
//]
